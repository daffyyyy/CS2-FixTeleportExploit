using CounterStrikeSharp.API;
using CounterStrikeSharp.API.Core;
using CounterStrikeSharp.API.Core.Attributes.Registration;
using CounterStrikeSharp.API.Modules.Utils;

namespace CS2_FixTeleportExploit;

public class CS2_FixTeleportExploit : BasePlugin
{
	Dictionary<int, PlayerPosition> playerPositions = new Dictionary<int, PlayerPosition>();

	public override string ModuleName => "CS2-FixTeleportExploit";
	public override string ModuleVersion => "1.0.0";
	public override string ModuleAuthor => "daffyy";

	public override void Load(bool hotReload)
	{
		RegisterListener<Listeners.OnMapStart>(OnMapStart);

		if (hotReload)
			OnMapStart(string.Empty);
	}

	private void OnMapStart(string mapName)
	{
		playerPositions.Clear();
		AddTimer(1.0f, () => CheckPlayersPosition(), CounterStrikeSharp.API.Modules.Timers.TimerFlags.REPEAT |
			CounterStrikeSharp.API.Modules.Timers.TimerFlags.STOP_ON_MAPCHANGE);
	}

	[GameEventHandler(HookMode.Pre)]
	public HookResult OnRoundStart(EventRoundStart @event, GameEventInfo info)
	{
		playerPositions.Clear();
		return HookResult.Continue;
	}

	[GameEventHandler]
	public HookResult OnPlayerDisconnect(EventPlayerDisconnect @event, GameEventInfo info)
	{
		if (@event.Userid is null || @event.Userid.IsBot || @event.Userid.IsHLTV) return HookResult.Continue;

		if (playerPositions.ContainsKey(@event.Userid.Slot))
			playerPositions.Remove(@event.Userid.Slot);

		return HookResult.Continue;
	}

	private void CheckPlayersPosition()
	{
		foreach (CCSPlayerController? player in Utilities.GetPlayers().Where(p => p is not null && p.IsValid && !p.IsBot && !p.IsHLTV && p.PawnIsAlive))
		{
			Vector? playerPosition = player.PlayerPawn?.Value?.AbsOrigin;
			if (playerPosition == null) continue;

			if ((int)playerPosition.Z < -530 || (int)playerPosition.Z == 0 && (int)playerPosition.Y == 0 && (int)playerPosition.X == 0)
				player.CommitSuicide(true, true);

			PlayerFlags flags = (PlayerFlags)player.PlayerPawn!.Value!.Flags;

			if ((!player.Buttons.HasFlag(PlayerButtons.Jump) && flags.HasFlag(PlayerFlags.FL_ONGROUND) ||
				!player.Buttons.HasFlag(PlayerButtons.Jump) && flags.HasFlag(PlayerFlags.FL_CLIENT) && !flags.HasFlag(PlayerFlags.FL_ONGROUND)) &&
				playerPositions.TryGetValue(player.Slot, out PlayerPosition storedPosition))
			{
				int diffX = (int)Math.Abs(playerPosition.X - storedPosition.X);
				int diffY = (int)Math.Abs(playerPosition.Y - storedPosition.Y);
				int diffZ = (int)Math.Abs(playerPosition.Z - storedPosition.Z);

				int threshold = 320;

				if (diffX > threshold || diffY > threshold || diffZ > threshold)
				{
					player.CommitSuicide(true, true);
				}
			}
			PlayerPosition lastPos = new((int)playerPosition.X, (int)playerPosition.Y, (int)playerPosition.Z);
			playerPositions[player.Slot] = lastPos;
		}
	}
}


public struct PlayerPosition
{
	public int X { get; set; }
	public int Y { get; set; }
	public int Z { get; set; }

	public PlayerPosition(int x, int y, int z)
	{
		X = x;
		Y = y;
		Z = z;
	}
}